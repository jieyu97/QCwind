data = as.data.frame(data)
obs.data = data[[column]]    # obs.data = data[,column]
output_data = data %>%
mutate(flag_range = if_else( (obs.data <= upper.bound & obs.data >= lower.bound), 'P', fail.flag, 'missing') ) %>%
mutate(new_data_range = ifelse( (obs.data <= upper.bound & obs.data >= lower.bound), obs.data, NA) )
output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_range']])) /
sum(!is.na(output_data[[column]]))
return(output_data)
}
library(tidyverse)
datetime = as.POSIXlt(seq(0,60000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(0:20,20:1,1:20,20:1,1:20))
test_range_check = range_check(test, column = 'windspeed', upper.bound = 18, fail.flag = 'RS')
attributes(test_range_check)
test_range_check
temporal_persist_check <- function(data, data.column, datetime.column,
persist.duration, min.variation, fail.flag)
{
require(tidyverse)
require(xts)
stopifnot(persist.duration > 0)
stopifnot(min.variation > 0)
stopifnot(is.character(fail.flag))
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
Sys.setenv(TZ = "GMT")
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# persist.duration = 3600
# min.variation = 0.1
# fail.flag = 'TS2'
data = as_tibble(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
data = data[order(data[[datetime.column]]),]
time_series = xts(x = obs.data, order.by = obs.datetime)
persist_dt_seq = tibble('start' = obs.datetime - persist.duration, 'end' = obs.datetime)
persist_dt_seq = persist_dt_seq[order(persist_dt_seq$start),]
persist_dt_label = str_c(persist_dt_seq$start,'/',persist_dt_seq$end)
variation.data = lapply(persist_dt_label, FUN = function(x){
ts_interval = time_series[x]
diff.value = ifelse(length(!is.na(ts_interval)) > 1,
max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
return(diff.value)
})
# variation.data = unlist( lapply(persist_dt_label, FUN = function(x){
#   ts_interval = time_series[x]
#   diff.value = ifelse(length(!is.na(ts_interval)) > 1,
#                       max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
#   return(diff.value)
# }) )
output_data = data %>%
mutate(flag_persist = if_else( variation.data <= min.variation,
fail.flag, 'P', 'isolated') ) %>%
mutate(new_data_persist = ifelse( flag_persist == fail.flag, NA, coredata(time_series) ) )
# output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_persist']])) /
sum(!is.na(obs.data))
return(output_data)
}
test_persist_check = temporal_persist_check(test, data.column = 'windspeed',
datetime.column = 'datetime',
persist.duration = 3600,
min.variation = 0.1, fail.flag = 'TS2')
attributes(test_persist_check)
test_persist_check
datetime = as.POSIXlt(seq(0,60000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(rep(10.2,5),seq(10,15,0.1),rep(9.3,45)))
test_persist_check = temporal_persist_check(test, data.column = 'windspeed',
datetime.column = 'datetime',
persist.duration = 3600,
min.variation = 0.1, fail.flag = 'TS2')
attributes(test_persist_check)
test_persist_check
temporal_persist_check <- function(data, data.column, datetime.column,
persist.duration, min.variation, fail.flag)
{
require(tidyverse)
require(xts)
stopifnot(persist.duration > 0)
stopifnot(min.variation > 0)
stopifnot(is.character(fail.flag))
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
Sys.setenv(TZ = "GMT")
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# persist.duration = 3600
# min.variation = 0.1
# fail.flag = 'TS2'
data = as_tibble(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
data = data[order(data[[datetime.column]]),]
time_series = xts(x = obs.data, order.by = obs.datetime)
persist_dt_seq = tibble('start' = obs.datetime - persist.duration, 'end' = obs.datetime)
persist_dt_seq = persist_dt_seq[order(persist_dt_seq$start),]
persist_dt_label = str_c(persist_dt_seq$start,'/',persist_dt_seq$end)
# variation.data = lapply(persist_dt_label, FUN = function(x){
#   ts_interval = time_series[x]
#   diff.value = ifelse(length(!is.na(ts_interval)) > 1,
#                       max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
#   return(diff.value)
# })
variation.data = unlist( lapply(persist_dt_label, FUN = function(x){
ts_interval = time_series[x]
diff.value = ifelse(length(!is.na(ts_interval)) > 1,
max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
return(diff.value)
}) )
output_data = data %>%
mutate(flag_persist = if_else( variation.data <= min.variation,
fail.flag, 'P', 'isolated') ) %>%
mutate(new_data_persist = ifelse( flag_persist == fail.flag, NA, coredata(time_series) ) )
# output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_persist']])) /
sum(!is.na(obs.data))
return(output_data)
}
datetime = as.POSIXlt(seq(0,60000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(rep(10.2,5),seq(10,15,0.1),rep(9.3,45)))
test_persist_check = temporal_persist_check(test, data.column = 'windspeed',
datetime.column = 'datetime',
persist.duration = 3600,
min.variation = 0.1, fail.flag = 'TS2')
attributes(test_persist_check)
test_persist_check
temporal_step_check <- function(data, data.column, datetime.column,
step.duration, max.variation, fail.flag)
{
require(tidyverse)
require(xts)
stopifnot(step.duration > 0)
stopifnot(max.variation > 0)
stopifnot(is.character(fail.flag))
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
Sys.setenv(TZ = "GMT")
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# step.duration = 720
# max.variation = 5
# fail.flag = 'TS1'
data = as.data.frame(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
time_series = xts(x = obs.data, order.by = obs.datetime)
step_dt_seq = tibble('start' = obs.datetime - step.duration, 'end' = obs.datetime)
step_dt_seq = step_dt_seq[order(step_dt_seq$start),]
step_dt_label = str_c(step_dt_seq$start,'/',step_dt_seq$end)
variation.data = unlist( lapply(step_dt_label, FUN = function(x){
ts_interval = time_series[x]
diff.value = ifelse(length(!is.na(ts_interval)) > 1,
max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
return(diff.value)
}) )
lag.data = dplyr::lag(coredata(time_series))
# lead.data = dplyr::lead(coredata(time_series))
lag.diff.data = abs(coredata(time_series) - lag.data)
# lead.diff.data = abs(coredata(time_series) - lead.data)
output_data = data[order(data[[datetime.column]]),] %>%
mutate(flag_step = ifelse( (variation.data > max.variation &
lag.diff.data > max.variation ),
fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
# mutate(flag = ifelse( (variation.data > max.variation &
#                           (lag.diff.data > max.variation |
#                           lead.diff.data > max.variation) ),
#                        fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
mutate(new_data_step = ifelse( flag == fail.flag, NA, coredata(time_series) ) )
output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_step']])) / sum(!is.na(obs.data))
return(output_data)
}
temporal_step_check <- function(data, data.column, datetime.column,
step.duration, max.variation, fail.flag)
{
require(tidyverse)
require(xts)
stopifnot(step.duration > 0)
stopifnot(max.variation > 0)
stopifnot(is.character(fail.flag))
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
Sys.setenv(TZ = "GMT")
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# step.duration = 720
# max.variation = 5
# fail.flag = 'TS1'
data = as_tibble(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
data = data[order(data[[datetime.column]]),]
time_series = xts(x = obs.data, order.by = obs.datetime)
step_dt_seq = tibble('start' = obs.datetime - step.duration, 'end' = obs.datetime)
step_dt_seq = step_dt_seq[order(step_dt_seq$start),]
step_dt_label = str_c(step_dt_seq$start,'/',step_dt_seq$end)
variation.data = unlist( lapply(step_dt_label, FUN = function(x){
ts_interval = time_series[x]
diff.value = ifelse(length(!is.na(ts_interval)) > 1,
max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
return(diff.value)
}) )
lag.data = dplyr::lag(coredata(time_series))
# lead.data = dplyr::lead(coredata(time_series))
lag.diff.data = abs(coredata(time_series) - lag.data)
# lead.diff.data = abs(coredata(time_series) - lead.data)
output_data = data %>%
mutate(flag_step = ifelse( (variation.data > max.variation &
lag.diff.data > max.variation ),
fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
# mutate(flag = ifelse( (variation.data > max.variation &
#                           (lag.diff.data > max.variation |
#                           lead.diff.data > max.variation) ),
#                        fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
mutate(new_data_step = ifelse( flag == fail.flag, NA, coredata(time_series) ) )
# output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_step']])) / sum(!is.na(obs.data))
return(output_data)
}
#' @param max.variation a positive number, the maximum allowed variability of observations.
#' @param fail.flag a character/string that represents the name of flag where an
#' observation fails the step check.
#' @return a new tbl_df that extends two new columns on the input data,
#' the first added column `flag` represents the flags (`P` means pass, `fail.flag` means fail,
#' `isolated` means missing previous observations), the second added column `new_data` represents
#' the observation data after removing failed observations.
#' @export
#' @examples
# library(tidyverse)
datetime = as.POSIXlt(seq(0,60000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(rep(10.2,5),seq(20,25,0.1),rep(9.3,45)))
test_step_check = temporal_step_check(test, data.column = 'windspeed',
datetime.column = 'datetime',
step.duration = 720,
max.variation = 5, fail.flag = 'TS1')
attributes(test_step_check)
temporal_step_check <- function(data, data.column, datetime.column,
step.duration, max.variation, fail.flag)
{
require(tidyverse)
require(xts)
stopifnot(step.duration > 0)
stopifnot(max.variation > 0)
stopifnot(is.character(fail.flag))
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
Sys.setenv(TZ = "GMT")
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# step.duration = 720
# max.variation = 5
# fail.flag = 'TS1'
data = as_tibble(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
data = data[order(data[[datetime.column]]),]
time_series = xts(x = obs.data, order.by = obs.datetime)
step_dt_seq = tibble('start' = obs.datetime - step.duration, 'end' = obs.datetime)
step_dt_seq = step_dt_seq[order(step_dt_seq$start),]
step_dt_label = str_c(step_dt_seq$start,'/',step_dt_seq$end)
variation.data = unlist( lapply(step_dt_label, FUN = function(x){
ts_interval = time_series[x]
diff.value = ifelse(length(!is.na(ts_interval)) > 1,
max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
return(diff.value)
}) )
lag.data = dplyr::lag(coredata(time_series))
# lead.data = dplyr::lead(coredata(time_series))
lag.diff.data = abs(coredata(time_series) - lag.data)
# lead.diff.data = abs(coredata(time_series) - lead.data)
output_data = data %>%
mutate(flag_step = ifelse( (variation.data > max.variation &
lag.diff.data > max.variation ),
fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
# mutate(flag = ifelse( (variation.data > max.variation &
#                           (lag.diff.data > max.variation |
#                           lead.diff.data > max.variation) ),
#                        fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
mutate(new_data_step = ifelse( flag_step == fail.flag, NA, coredata(time_series) ) )
# output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_step']])) / sum(!is.na(obs.data))
return(output_data)
}
datetime = as.POSIXlt(seq(0,60000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(rep(10.2,5),seq(20,25,0.1),rep(9.3,45)))
test_step_check = temporal_step_check(test, data.column = 'windspeed',
datetime.column = 'datetime',
step.duration = 720,
max.variation = 5, fail.flag = 'TS1')
attributes(test_step_check)
test_step_check
NA>9
temporal_step_check <- function(data, data.column, datetime.column,
step.duration, max.variation, fail.flag)
{
require(tidyverse)
require(xts)
stopifnot(step.duration > 0)
stopifnot(max.variation > 0)
stopifnot(is.character(fail.flag))
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
Sys.setenv(TZ = "GMT")
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# step.duration = 720
# max.variation = 5
# fail.flag = 'TS1'
data = as_tibble(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
data = data[order(data[[datetime.column]]),]
time_series = xts(x = obs.data, order.by = obs.datetime)
step_dt_seq = tibble('start' = obs.datetime - step.duration, 'end' = obs.datetime)
step_dt_seq = step_dt_seq[order(step_dt_seq$start),]
step_dt_label = str_c(step_dt_seq$start,'/',step_dt_seq$end)
variation.data = unlist( lapply(step_dt_label, FUN = function(x){
ts_interval = time_series[x]
diff.value = ifelse(length(!is.na(ts_interval)) > 1,
max(ts_interval, na.rm = TRUE) - min(ts_interval, na.rm = TRUE), NA)
return(diff.value)
}) )
lag.data = dplyr::lag(coredata(time_series))
# lead.data = dplyr::lead(coredata(time_series))
lag.diff.data = abs(coredata(time_series) - lag.data)
# lead.diff.data = abs(coredata(time_series) - lead.data)
output_data = data %>%
mutate(flag_step = ifelse( ( !is.na(variation.data) & variation.data > max.variation &
lag.diff.data > max.variation ),
fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
# mutate(flag = ifelse( (variation.data > max.variation &
#                           (lag.diff.data > max.variation |
#                           lead.diff.data > max.variation) ),
#                        fail.flag, ifelse(!is.na(variation.data), 'P', 'isolated') ) ) %>%
mutate(new_data_step = ifelse( flag_step == fail.flag, NA, coredata(time_series) ) )
# output_data = as_tibble(output_data)
attr(output_data, 'input_valid_data_percentage') = sum(!is.na(obs.data)) / length(obs.data)
attr(output_data, 'pass_percentage') = sum(!is.na(output_data[['new_data_step']])) / sum(!is.na(obs.data))
return(output_data)
}
datetime = as.POSIXlt(seq(0,60000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(rep(10.2,5),seq(20,25,0.1),rep(9.3,45)))
test_step_check = temporal_step_check(test, data.column = 'windspeed',
datetime.column = 'datetime',
step.duration = 720,
max.variation = 5, fail.flag = 'TS1')
attributes(test_step_check)
test_step_check
datetime = as.POSIXlt(seq(0,30000,300), origin = "2017-02-03 08:00:00")
datetime_seq_standard = as.POSIXlt(seq(0,30000,600), origin = "2017-02-03 08:00:00")
test = tibble(datetime = datetime,
windspeed = c(rep(10.2,5),seq(10,15,0.1),rep(9.3,45)))
standard_ts = uniform_data(data = test, data.column = 'windspeed',
datetime.column = 'datetime',
timeseq = datetime_seq_standard,
method = "average")
uniform_data = function(data, data.column, datetime.column,
timeseq, freq = 600, method = "average")
{
require(tidyverse)
require(xts)
stopifnot(is.data.frame(data))
stopifnot(is.character(data.column), data.column %in% colnames(data))
stopifnot(is.character(datetime.column), datetime.column %in% colnames(data))
stopifnot(lubridate::is.POSIXt(timeseq))
stopifnot(freq > 0)
stopifnot(is.character(method),
method %in% c("average", "maximum", "nearest", "angle.average"))
# # for test
# data = wow_test_each[[1]]
# data.column = 'windspeed_metrepersecond'
# datetime.column = 'datetime'
# timeseq = datetime_seq_test
# freq = 600
data = as.data.frame(data)
obs.data = data[[data.column]]    # data[,data.column]
obs.datetime = data[[datetime.column]]    # data[,datetime.column]
attr(obs.datetime, 'tzone') = "GMT"
time_series = xts(x = obs.data, order.by = obs.datetime)
standard_dt_seq = tibble('start' = timeseq - (freq/2),
'end' = timeseq + (freq/2 - 1) )
standard_dt_seq = standard_dt_seq[order(standard_dt_seq$start),]
standard_dt_label = str_c(standard_dt_seq$start,'/',standard_dt_seq$end)
# output_xts = xts(x = rep(NA, length(timeseq)), order.by = timeseq)
if (method == "average")
{
output.data = unlist( lapply(standard_dt_label, FUN = function(x){
ts_interval = time_series[x]
interval.data = ts_interval[!is.na(ts_interval)]
average.value = ifelse( length(interval.data) > 0, mean(interval.data), NA)
return(average.value)
}) )
}
else if (method == "maximum")
{
output.data = unlist( lapply(standard_dt_label, FUN = function(x){
ts_interval = time_series[x]
interval.data = ts_interval[!is.na(ts_interval)]
max.value = ifelse( length(interval.data) > 0, max(interval.data), NA)
return(max.value)
}) )
}
else if (method == "nearest")
{
time_series_intervals = lapply(standard_dt_label, FUN = function(x){
time_series[x] } )
output.data = unlist( lapply(1:length(time_series_intervals), FUN = function(i){
ts_interval = time_series_intervals[[i]]
ts_interval = ts_interval[!is.na(ts_interval)]
nearest.value = ifelse( length(ts_interval) > 0,
coredata(ts_interval)[which.min( abs( index(ts_interval) - timeseq[i]) )],
NA)
# nearest_label = which.min( abs( index(ts_interval) - timeseq[i]) )
# nearest.value = coredata(ts_interval)[nearest_label]
return(nearest.value)
}) )
}
else if (method == "angle.average")
{
output.data = unlist( lapply(standard_dt_label, FUN = function(x){
ts_interval = time_series[x]
interval.data = ts_interval[!is.na(ts_interval)]
average.angle = ifelse( length(interval.data) > 0, angle_average(interval.data), NA)
return(average.angle)
}) )
}
output_xts = xts(x = output.data, order.by = timeseq)
attr(output_xts,"tzone") = "GMT"
return(output_xts)
}
test
standard_ts = uniform_data(data = test, data.column = 'windspeed',
datetime.column = 'datetime',
timeseq = datetime_seq_standard,
method = "average")
standard_ts
str(standard_ts)
summary(standard_ts)
head(standard_ts)
devtools::document()
devtools::document()
devtools::document()
roxygen2::roxygenise()
devtools::install()
devtools::build_manual()
devtools::build_vignettes()
devtools::document()
rm(list = c("bias_correction", "internal_check_wind", "range_check", "temporal_persist_check", "temporal_step_check", "uniform_data"))
devtools::document()
devtools::document()
devtools::check()
Sys.setlocale(category = "LC_ALL", locale = "english")
# change language settings in R:
Sys.getlocale()
devtools::check()
Sys.setlocale(category = "LC_ALL", locale = "english")
Sys.getlocale()
devtools::check()
devtools::check()
load("E:/github/QCwind/data/wow_test.RData")
load("E:/github/QCwind/data/wow_test.RData")
devtools::build_manual()
devtools::build_manual()
devtools::build_vignettes()
library(tidyverse)
load("E:/R workspace/bc_compare_all.RData")
View(wow_info_final)
load("E:/R workspace/standard_qc_wow.RData")
load("E:/R workspace/windspeed_data.RData")
View(correlation_max_knmi)
View(emd_eqm)
View(spatial_wow_station_info)
View(new_knmi_info)
View(new_knmi_wd)
