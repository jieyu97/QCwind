
###########################################
# old
#########################################################

# need bc_compare_all, knmi_reference
############ correct order of new_knmi_info!!!!!!!
new_order = c(2,4,5,6,7,8,9,1,3,10,11,12)
new_knmi_info = new_knmi_info[new_order,]
new_knmi_info$location
colnames(new_knmi_ws)
################ go
all_bc_ws = cbind(wow_ws_bc_eqm, new_knmi_ws)
all_bc_stations = as.data.frame(cbind(1:51, colnames(all_bc_ws), 'wow',1,1))
colnames(all_bc_stations) = c('number','station','type','longitude','latitude')
all_bc_stations[40:51,3] = 'knmi'
all_bc_stations[40:51,1] = 1:12
all_bc_stations[1:39,4] = wow_info_final$longitude
all_bc_stations[1:39,5] = wow_info_final$latitude
all_bc_stations[40:51,4] = new_knmi_info$longitude
all_bc_stations[40:51,5] = new_knmi_info$latitude

# Earth Mover Distance / Wassestein-1 distance
emd_matrix_ws = matrix(NA, nrow = 51, ncol = 51)
Sys.time()
for (i in 2:51) {
  for (j in 1:(i-1)) {
    laws = which(!is.na(all_bc_ws[,i]) & !is.na(all_bc_ws[,j]))
    if (length(laws) != 0) {
      emd_matrix_ws[i,j] = sum( abs( sort(all_bc_ws[laws,i]) - sort(all_bc_ws[laws,j]) ) ) / length(laws)
    } else {
      emd_matrix_ws[i,j] = NA
    }
    # emd_matrix_ws[i,j] = wasserstein1d(all_bc_ws[laws,i], all_bc_ws[laws,j])
  }
}
Sys.time()
for (i in 2:51) {
  for (j in 1:(i-1)) {
    emd_matrix_ws[j,i] = emd_matrix_ws[i,j]
  }
}
for (i in 1:51) {
  emd_matrix_ws[i,i] = 0
}
# no NA!!!
dist_ws = emd_matrix_ws

fit <- cmdscale(dist_ws,eig=FALSE, k=2,add = TRUE)
name = all_bc_stations[,1:3]
mds = as.data.frame( cbind(1,1,name) )
colnames(mds) = c('coordinate_1','coordinate_2','number','stationID','group')
mds$coordinate_1 = fit$points[,1]
mds$coordinate_2 = fit$points[,2]

library(ggplot2)
ggplot(mds) +
  geom_point(aes(x = coordinate_1, y = coordinate_2, color = group, shape = group), size = 3) +
  annotate('text', x = mds$coordinate_1 + 0.08,
           y = mds$coordinate_2 + 0.05, label = mds$number,
           alpha = 1, size = 3.5) + theme_bw() + theme(legend.position = "bottom") +
  labs(title = 'Earth mover\'s distance space')

worldmap <- map_data('world')
map_stations = all_bc_stations
lon = as.numeric(all_bc_stations[,4])
lat = as.numeric(all_bc_stations[,5])
map_stations = as.data.frame(map_stations)
colnames(map_stations) = c('number','stationID','group','longitude','latitude')
map_stations$longitude = lon
map_stations$latitude = lat

ggplot(data = map_stations) +
  geom_point(aes(x = longitude, y = latitude, color = group, shape = group), size = 3) +
  annotate('text', x = map_stations$longitude + 0.03,
           y = map_stations$latitude + 0.03, label = map_stations$number,
           alpha = 1, size = 3.5) +
  geom_polygon(data = worldmap, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
  coord_map("ortho", orientation = c(50, 0, 0), xlim = c(4, 6.5), ylim = c(51, 53)) +
  theme_bw() + theme(legend.position = "bottom")

ggplot(data = new_knmi_info) +
  geom_point(aes(x = longitude, y = latitude), size = 3) +
  annotate('text', x = new_knmi_info$longitude + 0.03,
           y = new_knmi_info$latitude + 0.03, label = new_knmi_info$location,
           alpha = 1, size = 3.5) +
  geom_polygon(data = worldmap, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
  coord_map("ortho", orientation = c(50, 0, 0), xlim = c(4, 6.5), ylim = c(51, 53)) +
  theme_bw() + theme(legend.position = "bottom")

library(gridExtra)
grid.arrange(map_plot, mds_plot, ncol = 2)


###### without KNMI test stations:
library(geosphere)
dist_geo_ws = distm(cbind(map_stations$longitude[1:60],
                          map_stations$latitude[1:60]), fun = distGeo)
fit_geo <- cmdscale(dist_geo_ws,eig=TRUE, k=2)
name = all_bc_stations[1:60,1:3]
mds_geo = as.data.frame( cbind(1,1,name) )
colnames(mds_geo) = c('coordinate_1','coordinate_2','number','stationID','group')
mds_geo$coordinate_1 = fit_geo$points[,1]
mds_geo$coordinate_2 = fit_geo$points[,2]
mds_geo_plot = ggplot(mds_geo, aes(x = coordinate_1, y = coordinate_2, color = group)) +
  geom_point(alpha = 1, size = 2) +
  annotate('text', x = mds_geo$coordinate_1 + 0.02,
           y = mds_geo$coordinate_2 + 0.02, label = mds_geo$number,
           alpha = 0.9, size = 4) + theme(legend.position = "bottom")
###############################

# root mean square error - mds:
rmse_matrix_ws = matrix(NA, nrow = 51, ncol = 51)
for (i in 2:51) {
  for (j in 1:(i-1)) {
    laws = which(!is.na(all_bc_ws[,i]) & !is.na(all_bc_ws[,j]))
    if (length(laws) != 0) {
      rmse_matrix_ws[i,j] = sqrt(mean((all_bc_ws[laws,i] - all_bc_ws[laws,j])^2, na.rm = TRUE))
    } else {
      rmse_matrix_ws[i,j] = NA
    }
  }
}
for (i in 2:51) {
  for (j in 1:(i-1)) {
    rmse_matrix_ws[j,i] = rmse_matrix_ws[i,j]
  }
}
for (i in 1:51) {
  rmse_matrix_ws[i,i] = 0
}
dist_rmse_ws = rmse_matrix_ws
colnames(dist_rmse_ws) = 1:51
rownames(dist_rmse_ws) = 1:51

fit_rmse <- cmdscale(dist_rmse_ws,eig=FALSE, k=2,add = TRUE)
name = all_bc_stations[,1:3]
mds_rmse = as.data.frame( cbind(1,1,name) )
colnames(mds_rmse) = c('coordinate_1','coordinate_2','number','stationID','group')
mds_rmse$coordinate_1 = fit_rmse$points[,1]
mds_rmse$coordinate_2 = fit_rmse$points[,2]

ggplot(mds_rmse) +
  geom_point(aes(x = coordinate_1, y = coordinate_2, color = group, shape = group), size = 3) +
  annotate('text', x = mds_rmse$coordinate_1 + 0.08,
           y = mds_rmse$coordinate_2 + 0.05, label = mds_rmse$number,
           alpha = 1, size = 3.5) + theme_bw() + theme(legend.position = "bottom") +
  labs(title = 'Root mean square error space')


# check 20 35 39 11 14
k = 35
wow = wow_ws_bc_eqm[,k]
i = correlation_max_knmi$spd_after_p[k]
knmi = new_knmi_ws[,i]
check = as.data.frame(cbind(knmi,wow))
ggplot(check) +
  stat_ecdf(aes(knmi), geom = "step", color = 'steelblue', linetype = 'dashed') +
  stat_ecdf(aes(wow), geom = "step", color = 'grey30')

ggplot(check) + geom_point(aes(knmi,wow), color = 'steelblue',alpha = 0.2)
ggplot(check) + geom_histogram(aes(knmi, ..density..), fill = 'steelblue',alpha = 0.8,binwidth = 0.5) +
  geom_histogram(aes(wow, ..density..), fill = 'red',alpha = 0.3,binwidth = 0.5)

#### test
ggplot(new_knmi_ws) +
  stat_ecdf(aes(new_knmi_ws[,1]), geom = "step") +
  stat_ecdf(aes(new_knmi_ws[,2]), geom = "step", color = 'darkred') +
  stat_ecdf(aes(new_knmi_ws[,3]), geom = "step", color = 'steelblue') +
  stat_ecdf(aes(new_knmi_ws[,4]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,5]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,6]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,7]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,8]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,9]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,10]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,11]), geom = "step", color = 'grey30') +
  stat_ecdf(aes(new_knmi_ws[,12]), geom = "step", color = 'grey30')

#################################################
# new
###################################################

select_wow = colnames(wow_ws_bc_qq)
select_wow_la = which(wow_station_information_used$station_id %in% select_wow)
select_wow_info = wow_station_information_used[select_wow_la,]
library(geosphere)
library(ggplot2)
select_wow_dist = distm(cbind(select_wow_info$longitude,
                              select_wow_info$latitude), fun = distGeo)
select_wow_corr = cor(as.matrix(wow_ws_bc_qq), use = 'pairwise.complete.obs', method = "pearson")
wow_dist = select_wow_dist[upper.tri(select_wow_dist, diag = FALSE)]
wow_corr = select_wow_corr[upper.tri(select_wow_corr, diag = FALSE)]
wow_comp = as.data.frame(cbind(wow_dist,wow_corr))
ggplot(wow_comp, aes(wow_dist,wow_corr)) + geom_point() + theme_bw() +
  labs(x = 'distance (meter)', y = 'correlation')
ggplot(wow_comp, aes(wow_corr)) + theme_bw() +
  geom_boxplot(outlier.size=1) + coord_flip() +
  labs(x = 'correlation')
mean(wow_corr) #0.5803637
quantile (wow_corr, probs = c (0, .25, .5,.75, 1))
quantile (wow_dist, probs = c (0, .25, .5,.75, .95, 1))



knmi_official_label = c(1:3,5,19,20,22,25,27,33:36,39,43,47,49,53,55:58)
knmi_test_label = c(4,6:18,21,23,24,26,31,32,37,38,40:42,44:46,48,50:52,54)
knmi_nbhd_information_official = knmi_nbhd_information[knmi_official_label,]
knmi_nbhd_information_test = knmi_nbhd_information[knmi_test_label,]
knmi_official_ws = knmi_ws[,knmi_official_label]
knmi_test_ws = knmi_ws[,knmi_test_label]
knmi_official_wg = knmi_wg[,knmi_official_label]
knmi_test_wg = knmi_wg[,knmi_test_label]
knmi_official_wd = knmi_wd[,knmi_official_label]
knmi_test_wd = knmi_wd[,knmi_test_label]
wow_label = c(1:23,26:65)
all_ws = cbind(wow_ws_after_I1[,wow_label], knmi_official_ws, knmi_test_ws)
all_wg = cbind(wow_wg_after_I1[,wow_label], knmi_official_wg, knmi_test_wg)
all_wd = cbind(wow_wd_after_T3[,wow_label], knmi_official_wd, knmi_test_wd)

all_stations = cbind(1:118, colnames(all_ws), 'WOW',1,1)
all_stations[64:85,3] = 'KNMI_official'
all_stations[86:118,3] = 'KNMI_test'
all_stations[1:63,1] = wow_label
all_stations[64:85,1] = 1:22
all_stations[86:118,1] = 1:33
all_stations[1:63,4] = wow_station_information_used$longitude[wow_label]
all_stations[1:63,5] = wow_station_information_used$latitude[wow_label]
all_stations[64:85,4] = knmi_nbhd_information_official$longitude
all_stations[64:85,5] = knmi_nbhd_information_official$latitude
all_stations[86:118,4] = knmi_nbhd_information_test$longitude
all_stations[86:118,5] = knmi_nbhd_information_test$latitude

# Earth Mover Distance / Wassestein-1 distance
emd_matrix_ws = matrix(NA, nrow = 118, ncol = 118)
emd_matrix_wg = matrix(NA, nrow = 118, ncol = 118)
emd_matrix_wd = matrix(NA, nrow = 118, ncol = 118)
Sys.time()
for (i in 2:118) {
  for (j in 1:(i-1)) {
    laws = which(!is.na(all_ws[,i]) & !is.na(all_ws[,j]))
    if (length(laws) != 0) {
      emd_matrix_ws[i,j] = sum( abs( sort(all_ws[laws,i]) - sort(all_ws[laws,j]) ) ) / length(laws)
    } else {
      emd_matrix_ws[i,j] = NA
    }
    # emd_matrix_ws[i,j] = wasserstein1d(all_ws[laws,i], all_ws[laws,j])
    lawg = which(!is.na(all_wg[,i]) & !is.na(all_wg[,j]))
    if (length(lawg) != 0) {
      emd_matrix_wg[i,j] = sum( abs( sort(all_wg[lawg,i]) - sort(all_wg[lawg,j]) ) ) / length(lawg)
    } else {
      emd_matrix_wg[i,j] = NA
    }
    # emd_matrix_wg[i,j] = wasserstein1d(all_wg[lawg,i], all_wg[lawg,j])
    lawd = which(!is.na(all_wd[,i]) & !is.na(all_wd[,j]))
    if (length(lawd) != 0) {
      emd_matrix_wd[i,j] = sum( abs( sort(all_wd[lawd,i]) - sort(all_wd[lawd,j]) ) ) / length(lawd)
    } else {
      emd_matrix_wd[i,j] = NA
    }
    # emd_matrix_wd[i,j] = wasserstein1d(all_wd[lawd,i], all_wd[lawd,j])
  }
}
Sys.time()
for (i in 2:118) {
  for (j in 1:(i-1)) {
    emd_matrix_ws[j,i] = emd_matrix_ws[i,j]
    emd_matrix_wg[j,i] = emd_matrix_wg[i,j]
    emd_matrix_wd[j,i] = emd_matrix_wd[i,j]
  }
}
for (i in 1:118) {
  emd_matrix_ws[i,i] = 0
  emd_matrix_wg[i,i] = 0
  emd_matrix_wd[i,i] = 0
}

dist_ws = emd_matrix_ws
colnames(dist_ws) = 1:118
rownames(dist_ws) = 1:118
dist_ws = dist_ws[-27, -27]
dist_ws = dist_ws[complete.cases(dist_ws), complete.cases(dist_ws)]

as.numeric(colnames(dist_ws))



fit <- cmdscale(dist_ws,eig=TRUE, k=2)
name = all_stations[as.numeric(colnames(dist_ws)),1:3]
mds = as.data.frame( cbind(1,1,name) )
colnames(mds) = c('coordinate_1','coordinate_2','number','stationID','group')
mds$coordinate_1 = fit$points[,1]
mds$coordinate_2 = fit$points[,2]

dput(cmdscale)
###########################################
function (d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE,
          list. = eig || add || x.ret)
{
  if (anyNA(d))
    stop("NA values not allowed in 'd'")
  if (!list.) {
    if (eig)
      warning("eig=TRUE is disregarded when list.=FALSE")
    if (x.ret)
      warning("x.ret=TRUE is disregarded when list.=FALSE")
  }
  if (is.null(n <- attr(d, "Size"))) {
    if (add)
      d <- as.matrix(d)
    x <- as.matrix(d^2)
    storage.mode(x) <- "double"
    if ((n <- nrow(x)) != ncol(x))
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    rn <- attr(d, "Labels")
    x <- matrix(0, n, n)
    if (add)
      d0 <- x
    x[row(x) > col(x)] <- d^2
    x <- x + t(x)
    if (add) {
      d0[row(x) > col(x)] <- d
      d <- d0 + t(d0)
    }
  }
  n <- as.integer(n)
  if (is.na(n) || n > 46340)
    stop(gettextf("invalid value of %s", "'n'"), domain = NA)
  if ((k <- as.integer(k)) > n - 1 || k < 1)
    stop("'k' must be in {1, 2, ..  n - 1}")
  x <- .Call(C_DoubleCentre, x)
  if (add) {
    i2 <- n + (i <- 1L:n)
    Z <- matrix(0, 2L * n, 2L * n)
    Z[cbind(i2, i)] <- -1
    Z[i, i2] <- -x
    Z[i2, i2] <- .Call(C_DoubleCentre, 2 * d)
    e <- eigen(Z, symmetric = FALSE, only.values = TRUE)$values
    add.c <- max(Re(e))
    x <- matrix(double(n * n), n, n)
    non.diag <- row(d) != col(d)
    x[non.diag] <- (d[non.diag] + add.c)^2
    x <- .Call(C_DoubleCentre, x)
  }
  e <- eigen(-x/2, symmetric = TRUE)
  ev <- e$values[seq_len(k)]
  evec <- e$vectors[, seq_len(k), drop = FALSE]
  k1 <- sum(ev > 0)
  if (k1 < k) {
    warning(gettextf("only %d of the first %d eigenvalues are > 0",
                     k1, k), domain = NA)
    evec <- evec[, ev > 0, drop = FALSE]
    ev <- ev[ev > 0]
  }
  points <- evec * rep(sqrt(ev), each = n)
  dimnames(points) <- list(rn, NULL)
  if (list.) {
    evalus <- e$values
    list(points = points, eig = if (eig) evalus, x = if (x.ret) x,
         ac = if (add) add.c else 0, GOF = sum(ev)/c(sum(abs(evalus)),
                                                     sum(pmax(evalus, 0))))
  }
  else points
}
##############################################################

library(ggplot2)
ggplot(mds, aes(x = coordinate_1, y = coordinate_2, color = group)) + geom_point(alpha = 1, size = 2) +
  annotate('text', x = mds$coordinate_1,
           y = mds$coordinate_2 + 0.01, label = mds$number,
           colour = I('steelblue'), size = 3)

count = apply(wow_ws, 1, function(x){
  sum(!is.na(x))
})
count_wow_ws = as.data.frame( cbind(1, count) )
colnames(count_wow_ws) = c('datetime','count')
count_wow_ws[,1] = datetime_sequence

ggplot(data = count_wow_ws, aes(x = datetime)) +
  geom_point(aes(y = count), size = 0.1, alpha = 0.2, color = 'steelblue')


worldmap <- map_data('world')
map_stations = all_stations
lon = as.numeric(all_stations[,4])
lat = as.numeric(all_stations[,5])
map_stations = as.data.frame(map_stations)
colnames(map_stations) = c('number','stationID','group','longitude','latitude')
map_stations$longitude = lon
map_stations$latitude = lat


ggplot(data = map_stations, aes(x = longitude, y = latitude, color = group) ) +
  geom_point() +
  annotate('text', x = map_stations$longitude + 0.01,
           y = map_stations$latitude + 0.01, label = map_stations$number,
           colour = 'steelblue', size = 3) +
  geom_polygon(data = worldmap, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
  coord_fixed(xlim = c(4,7), ylim = c(51, 53.5)) +
  theme(legend.position = "bottom")



wow_ws

count_wow_wspd = cbind( wow_ws[,c(1:23,26:65)], datetime_sequence )
for (k in 1:63) {
  count_wow_wspd[!is.na(count_wow_wspd[,k]),k] = k
}
class(count_wow_wspd$datetime_sequence)
library(reshape2)
count_wow_wspd_all <- melt(count_wow_wspd, id.vars = 'datetime_sequence')
count_wow_wspd_all$variable = NA
count_wow_wspd_all$variable[!is.na(count_wow_wspd_all$value)] = 1

# not good
ggplot(count_wow_wspd_all, aes(x = datetime_sequence, y = value)) +
  geom_point(alpha = 0.96, shape = '.', color = 'steelblue')
# not good
ggplot(count_wow_wspd_all, aes(x = datetime_sequence, y = value)) +
  geom_tile(color = 'steelblue')
# perfect
ggplot(count_wow_wspd_all, aes(x = datetime_sequence, y = value)) +
  geom_rect(aes(xmin = datetime_sequence-7200, xmax = datetime_sequence+7200, ymin = value-0.2, ymax = value+0.2),
            alpha = 0.1, color = 'darkgrey') +
  xlab("date-time (year)") + ylab("WOW station number (#)") + theme_bw() +
  scale_y_continuous( breaks = seq(0,64,4), limits = c(0, 64) )




plot_ly(x = count_wow_wspd_all$datetime_sequence, y = count_wow_wspd_all$value, z = count_wow_wspd_all$variable,
        type = "heatmap")


##################################
# change
############ bias correction
library(ggplot2)
k=28 # 1,3,4,5,9,38,44, good: 20, 28; medium: 12, 16; bad: 15, 3
wow_test = wow_ws_after_I1[,k]
wow_test_nonzero = wow_test[which(wow_test != 0)]
knmi_test = knmi_official_ws[,wow_knmi_official_nearest[k]]
knmi_test_nonzero = knmi_test[which(wow_test != 0)]
linear_regression = lm(wow_test_nonzero ~ knmi_test_nonzero)
slope = linear_regression$coefficients[2]
intersec = linear_regression$coefficients[1]

wow_correct = wow_test_nonzero / slope # too large
wow_correct_test = (wow_test_nonzero - intersec) / slope # have negative ws value
wow_correct_fix = wow_test_nonzero + linear_regression_single$coefficients[1]
# wow_correct_fix = (wow_test_nonzero * 8) / (8 * slope + intersec)
bias_correction_test = as.data.frame( cbind(knmi_test_nonzero, wow_test_nonzero, wow_correct,
                                            wow_correct_test, wow_correct_fix) )

ggplot(bias_correction_test, aes(x = knmi_test_nonzero) ) +
  geom_point( aes(y = wow_test_nonzero), alpha = 0.3, color = 'darkred') +
  geom_point( aes(y = wow_correct_fix), alpha = 0.2, color = 'steelblue') +
  labs(y = paste('KNMI',knmi_nbhd_information_official$NAME[i],'wind speed'),
       x = paste('WOW station',k,'(nonzero) wind speed'),
       title = 'Bias correction method: WOW + constant') +
  geom_abline()
# Bias correction method: WOW + constant, (WOW - intersec) / slope of linear regression, WOW /

ggplot(bias_correction_test, aes(x = knmi_test_nonzero, y = wow_test_nonzero) ) +
  geom_point(alpha = 0.2, color = 'pink') +
  geom_smooth(method='lm', colour='darkred') +
  geom_abline() + theme_bw()
# loess

k=44
38, 44,
wow_test = wow_ws_after_I1[,k]
knmi_test = knmi_official_ws[,wow_knmi_official_nearest[k]]
linear_regression = lm(wow_test ~ knmi_test)
slope = linear_regression$coefficients[2]
intersec = linear_regression$coefficients[1]

wow_correct = wow_test / slope # too large
wow_correct_test = (wow_test - intersec) / slope # have negative ws value
wow_correct_fix = (wow_test * 8) / (8 * slope + intersec)
wow_correct_paper = wow_test * (1 + slope)
bias_correction_test = as.data.frame( cbind(knmi_test, wow_test, wow_correct,
                                            wow_correct_test, wow_correct_fix, wow_correct_paper) )

ggplot(bias_correction_test, aes(x = knmi_test) ) +
  geom_point( aes(y = wow_test), alpha = 0.3, color = 'darkred') +
  geom_point( aes(y = wow_correct_fix), alpha = 0.2, color = 'steelblue') +
  geom_point( aes(y = wow_correct_paper), alpha = 0.1, color = 'orange') + geom_abline()


 ggplot(bias_correction_test, aes(x = knmi_test, y = wow_test) ) +
  geom_point(alpha = 0.2, color = 'pink') +
  geom_smooth(method='lm', colour='darkred') +
  geom_abline() +theme_bw()

# end
##########################################

library(geosphere)
wow_knmi_official_distance = distm(x = cbind(wow_station_information_used$longitude,
                                         wow_station_information_used$latitude),
                               y = cbind(knmi_nbhd_information_official$longitude,
                                         knmi_nbhd_information_official$latitude),
                               fun = distGeo)
wow_knmi_official_distance[,6] = NA
wow_knmi_official_nearest = c()
for (k in 1:67) {
  wow_knmi_official_nearest[k] = which.min(wow_knmi_official_distance[k,])
}

wow_ws_correct = wow_ws_after_I1

for (k in c(1:23,26:28,30:65)) {
  wow_test = wow_ws_after_I1[,k]
  knmi_test = knmi_official_ws[,wow_knmi_official_nearest[k]]
  linear_regression = lm(wow_test ~ knmi_test)
  slope = linear_regression$coefficients[2]
  intersec = linear_regression$coefficients[1]
  wow_ws_correct[,k] = wow_ws_after_I1[,k] / slope
}

for (k in c(1:23,26:28,30:65)) {
  wow_test = wow_ws_after_I1[,k]
  knmi_test = knmi_official_ws[,wow_knmi_official_nearest[k]]
  linear_regression = lm(wow_test ~ knmi_test)
  print(linear_regression)
  print(k)
}



######################## 95 WOW ################

wow_locate = as.data.frame(matrix(NA,95,4))
colnames(wow_locate) = c('number','id','lon','lat')
for (i in 1:95) {
  wow_locate$number[i] = i
  wow_locate$id[i] = as.character(station_data_each[[i]]$station_id[1])
  wow_locate$lon[i] = station_data_each[[i]]$longitude[1]
  wow_locate$lat[i] = station_data_each[[i]]$latitude[1]
}

worldmap <- map_data('world')
ggplot() + geom_point(aes(x = lon, y = lat), data = wow_locate,
                      color = 'steelblue') +
  geom_polygon(data = worldmap, aes(x=long, y = lat, group = group), fill = NA, color = "black") +
  # coord_fixed(xlim = c(4,7), ylim = c(51, 53.5)) +
  coord_map("ortho", orientation = c(50, 0, 0), xlim = c(4, 7), ylim = c(51, 53.5)) +
  theme(legend.position = "bottom") +
  theme_bw()


########################### figure to explain emd
knmi1 = new_knmi_ws[,6]
knmi2 = new_knmi_ws[,9]
emd_knmi_e = as.data.frame(cbind(knmi1,knmi2))
library(ggplot2)
ggplot(emd_knmi_e) + theme_bw() +
  geom_density(aes(knmi1, ..density..), fill = 'red', alpha = 0.4) +
  geom_density(aes(knmi2, ..density..), fill = 'blue', alpha = 0.3) +
  labs(x = 'wind speed',y = 'frequency (density)')
