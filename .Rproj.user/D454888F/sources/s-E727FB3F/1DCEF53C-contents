
###########
# test
ggplot(knmi_official_ws, aes(knmi_official_ws[,7], knmi_official_ws[,6]) ) +
  geom_bin2d(binwidth = c(0.5, 0.5)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw()
ggplot(knmi_official_ws, aes(knmi_official_ws[,7], knmi_official_ws[,6]) ) +
  geom_point(color = 'steelblue', alpha = 0.2) +
  geom_abline(color = 'darkred') + theme_bw()
debilt_o = knmi_official_ws[,7]
debilt_t = knmi_official_ws[,6]
debilt_o_hour = 1:26304
debilt_t_hour = 1:26304
for (t in 1:26304) {
  debilt_o_hour[t] = mean(debilt_o[(t*6-5):(t*6)], na.rm = TRUE)
  debilt_t_hour[t] = mean(debilt_t[(t*6-5):(t*6)], na.rm = TRUE)
}
ggplot(as.data.frame(cbind(debilt_o,debilt_t)), aes(debilt_o, debilt_t) ) +
  geom_bin2d(binwidth = c(0.4, 0.4)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw()
ggplot(as.data.frame(cbind(debilt_o_hour,debilt_t_hour)), aes(debilt_o_hour,debilt_t_hour) ) +
  geom_bin2d(binwidth = c(0.4, 0.4)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw()
d = 1 # 2 3 4 5 6 7 10 15 30
n = 6*24*d
t = sample((n+1):157825, 10, replace=F)
t
ggplot(as.data.frame(cbind(debilt_o_hour[t:(t+n-1)],debilt_t_hour[t:(t+n-1)])),
       aes(debilt_o_hour[t:(t+n-1)],debilt_t_hour[t:(t+n-1)]) ) +
  geom_point(color = 'steelblue', alpha = 0.2) +
  geom_abline(color = 'darkred') + theme_bw()
nl = lm( debilt_t_hour[t:(t+n-1)] ~ debilt_o_hour[t:(t+n-1)] )
summary(nl)
error = sqrt( sum(nl$residuals**2) / nl$df.residual)
error = sqrt( mean(nl$residuals**2) )
qqnorm(nl$resid)
qqline(nl$resid)


# 2. spatial regression test (SRT)
nhour = 4
twindow = 6*nhour
# set empty matrix
estimation_srt_mat = matrix(NA, nrow = 157825, ncol = 39) # estimation 3
sd_srt_mat = estimation_srt_mat # nbhd sd 3

# big loop
time_window = 24
spatial_srt_ws = spatial_ws
spatial_srt_flag = spatial_ws

Sys.time()
for (k in 1:38 )
{
  i = wow_station_order[k]
  # observation WOW
  observation = spatial_srt_ws[,i]
  estimation_srt = as.numeric(matrix(NA, nrow = 1, ncol = 157825)) # estimation 3
  sd_srt = estimation_srt # nbhd sd 3

  nbhd_label = wow_spatial_nbhd[[k]]

  period = intersect( which(!is.na(observation)), ( (time_window+1):length(observation) ) )
  for (t in period) {
    window_candi = observation[(t-time_window):(t-1)]
    window_nbhd = spatial_srt_ws[(t-time_window):(t-1), nbhd_label]
    spatial_estimate = c(NA,NA,NA,NA,NA,NA)
    weight_srt = c(NA,NA,NA,NA,NA,NA)

    if (sum(!is.na(window_candi)) < 12) {
      spatial_srt_flag[t,i] = 0
    } else {
      for (p in 1:6) {
        if (sum(!is.na(window_candi) & !is.na(window_nbhd[,p])) >= 12) {
          linear = lm(window_candi ~ window_nbhd[,p])
          window_nbhd_now = spatial_srt_ws[t,nbhd_label[p]]
          spatial_estimate[p] = window_nbhd_now * linear$coefficients[2] + linear$coefficients[1]
          weight_srt[p] = sqrt( sum(linear$residuals**2) / linear$df.residual) # Residual Standard error
        }
      }
      estimation_srt[t] = sqrt(sum(spatial_estimate^2 / weight_srt^2, na.rm = TRUE)) /
        sqrt(sum(1 / weight_srt^2, na.rm = TRUE))
      sd_srt[t] = sqrt( 1 / mean( 1 / weight_srt^2, na.rm = TRUE) )
    }
  }

  flag_after_srt = ifelse( observation > (estimation_srt + 2*sd_srt) |
                             observation < (estimation_srt - 2*sd_srt),
                           1, 0 )
  obs_after_srt = ifelse( observation > (estimation_srt + 2*sd_srt) |
                            observation < (estimation_srt - 2*sd_srt),
                          NA, observation )

  estimation_srt_mat[,i] = estimation_srt
  sd_srt_mat[,i] = sd_srt
  spatial_srt_ws[,i] = obs_after_srt
  spatial_srt_flag[,i] = flag_after_srt
  print(k)
}
Sys.time()
##################################################
# add & check remove or not
### Combined SRT method:

# big loop
time_window = 6*24
spatial_csrt_ws = spatial_ws
spatial_csrt_flag = spatial_ws

for (k in 11:13)
{
  i = wow_station_order[k]
  # observation WOW
  observation = spatial_csrt_ws[,i]
  estimation_csrt = as.numeric(matrix(NA, nrow = 1, ncol = 157825)) # estimation 3
  sd_csrt = estimation_csrt # nbhd sd 3

  nbhd_label = wow_spatial_nbhd[[k]]

  period = intersect( which(!is.na(observation)), ( (time_window+1):length(observation) ) )
  for (t in period) {
    window_candi = observation[(t-time_window):(t-1)]
    window_nbhd = spatial_csrt_ws[(t-time_window):(t-1), nbhd_label]
    spatial_estimate = c(NA,NA,NA,NA,NA,NA)
    weight_csrt = c(NA,NA,NA,NA,NA,NA)

    if (sum(!is.na(window_candi)) < 72) {
      spatial_srt_flag[t,i] = 0
    } else {
      for (p in 1:6) {
        if (sum(!is.na(window_candi) & !is.na(window_nbhd[,p])) >= 72) {
          linear = lm(window_candi ~ window_nbhd[,p])
          window_nbhd_now = spatial_csrt_ws[t,nbhd_label[p]]
          spatial_estimate[p] = window_nbhd_now * linear$coefficients[2] + linear$coefficients[1]
          mu_window_nbhd = mean(window_nbhd[,p], na.rm = TRUE)
          weight_csrt[p] = 1 -
            sum( abs(window_candi - window_nbhd[,p]), na.rm = TRUE) /
            sum( abs(window_candi - mu_nbhd) +
                   abs(window_nbhd[,p] - mu_nbhd), na.rm = TRUE)
          # index of agreement
        }
      }
    }
    if (sum(!is.na(spatial_estimate)) >= 3) {
      estimation_csrt[t] = sum(spatial_estimate * weight_csrt, na.rm = TRUE) /
        sum(weight_csrt, na.rm = TRUE)
      sd_csrt[t] = sd(spatial_estimate, na.rm = TRUE)
    } else {
      estimation_csrt[t] = NA
      sd_csrt[t] = NA
    }
  }

  flag_after_csrt = ifelse( observation <= (estimation_csrt + 3*sd_csrt) &
                              observation >= (estimation_csrt - 3*sd_csrt),
                            0, 1 )
  obs_after_csrt = ifelse( observation <= (estimation_csrt + 3*sd_csrt) &
                             observation >= (estimation_csrt - 3*sd_csrt),
                           observation, NA )

  spatial_csrt_ws[,i] = obs_after_csrt
  spatial_csrt_flag[,i] = flag_after_csrt
}


before = ggplot(spatial_ws, aes(spatial_ws[,32], spatial_ws[,3]) ) +
  geom_bin2d(binwidth = c(0.5, 0.5)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw() + labs(y = 'WOW wind speed',
                    x = 'KNMI wind speed',
                    title = 'After bias correction')
after = ggplot(spatial_srt_ws, aes(spatial_srt_ws[,32],
                                   spatial_srt_ws[,3]) ) +
  geom_bin2d(binwidth = c(0.5, 0.5)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw() + labs(y = 'WOW wind speed',
                    x = 'KNMI wind speed',
                    title = 'After SRT')
after_r = ggplot(spatial_csrt_ws, aes(spatial_csrt_ws[,32],
                                      spatial_csrt_ws[,3]) ) +
  geom_bin2d(binwidth = c(0.5, 0.5)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw() + labs(y = 'WOW wind speed',
                    x = 'KNMI wind speed',
                    title = 'After combined SRT')
grid.arrange(before, after, after_r, ncol = 3)

ggplot() +
  geom_histogram(aes(spatial_ws[,3]), binwidth = 0.5, fill = 'darkred', alpha = 0.7) +
  geom_histogram(aes(spatial_srt_ws[,3]), binwidth = 0.5, fill = 'darkgreen', alpha = 0.7) +
  geom_histogram(aes(spatial_csrt_ws[,3]), binwidth = 0.5, fill = 'steelblue', alpha = 0.6) +
  theme_bw() + labs(x = 'wind speed')

gof(spatial_srt_ws[,3], spatial_ws[,32])
gof(spatial_csrt_ws[,3], spatial_ws[,32])

# 2. spatial regression test (SRT)
nday = 25
twindow = 6*24*nday
# set empty matrix
estimation_srt_mat = matrix(NA, nrow = 157825, ncol = 38) # estimation 3
sd_srt_mat = estimation_srt_mat # nbhd sd 3

# big loop
Sys.time()
for (i in spatial_nbhd_info_order[,3]) {

}
i = spatial_nbhd_info_order[1,3]
observation = spatial_ws[,i]
estimation_srt = as.numeric(matrix(NA, nrow = 1, ncol = 157825)) # estimation 3
sd_srt = estimation_srt # nbhd sd 3
label_nbhd = which(spatial_distance[,i] <= radius & spatial_distance[,i] != 0)
# similarity, nbhd ordering
similar_nbhd_info = matrix(NA, nrow = length(label_nbhd), ncol = 4)
colnames(similar_nbhd_info) = c('nbhd_label','w0k1','rmse','correlation')
similar_nbhd_info[,1] = label_nbhd
similar_nbhd_info[,2] = spatial_information$w0k1[label_nbhd]
for (j in 1:length(label_nbhd) ) {
  similar_nbhd_info[j,3] = sqrt(mean((spatial_ws[,i] - spatial_ws[,label_nbhd[j]])^2, na.rm = TRUE))
  similar_nbhd_info[j,4] = cor(spatial_ws[,i], spatial_ws[,label_nbhd[j]],
                               use = 'pairwise.complete.obs', method = 'pearson')
}
similar_nbhd_info_sort = similar_nbhd_info[which(similar_nbhd_info[,4] >= 0.5),]
similar_nbhd_info_order = similar_nbhd_info_sort[order(similar_nbhd_info_sort[,3]),]
########################################################################################

notNA = which(!is.na(observation[(twindow+1):157825])) + twindow
for (t in notNA) {
  # single estimation
  # t = 9000
  n = 0
  single_estimation_srt = c(NA, NA, NA, NA, NA)
  single_sd_srt = c(NA, NA, NA, NA, NA)
  observation_ws = observation[(t-twindow):t]
  observation_hourly = sapply( seq(1, twindow+1, 6),
                               function(i) {mean(observation_ws[i:(i+5)], na.rm = TRUE)})
  if ( sum(!is.na(observation_hourly)) < 400 ) {
  } else {
    # k-th nbhd
    for (k in similar_nbhd_info_order[,1]) {
      # k=1
      single_ws = spatial_ws[(t-twindow):t,k]
      single_ws_hourly = sapply( seq(1, twindow+1, 6),
                                 function(i) {mean(single_ws[i:(i+5)], na.rm = TRUE)})
      if ( sum(!is.na(single_ws_hourly)) < 500 ) {
        n = n
      } else if ( !is.na(single_ws_hourly[601]) ) {
        n = n+1
        linear = lm(observation_hourly[1:600] ~ single_ws_hourly[1:600])
        single_estimation_srt[n] = single_ws_hourly[601] * linear$coefficients[2] + linear$coefficients[1]
        single_sd_srt[n] = sqrt( sum(linear$residuals**2) / linear$df.residual) # Residual Standard error
      } else { n = n }
      if (n == 5) { break }
    }
    estimation_srt[t] = sqrt(sum(single_estimation_srt^2 / single_sd_srt^2, na.rm = TRUE)) /
      sqrt(sum(1 / single_sd_srt^2, na.rm = TRUE))
    sd_srt[t] = sqrt( 1 / mean( 1 / single_sd_srt^2, na.rm = TRUE) )
  }
}


# 3. combined srt, csrt
estimation_csrt = as.numeric(matrix(NA, nrow = 1, ncol = 157825)) # estimation 4
sd_csrt = estimation_srt # nbhd sd 4
for (t in notNA) {
  # single estimation
  # t = 9000
  n = 0
  single_estimation_csrt = c(NA, NA, NA, NA, NA)
  single_sd_csrt = c(NA, NA, NA, NA, NA)
  csrt_nbhd_ws = c(NA, NA, NA, NA, NA)
  observation_ws = observation[(t-twindow):t]
  observation_hourly = sapply( seq(1, twindow+1, 6),
                               function(i) {mean(observation_ws[i:(i+5)], na.rm = TRUE)})
  if ( sum(!is.na(observation_hourly)) < 400 ) {
  } else {
    # k-th nbhd
    for (k in similar_nbhd_info_order[,1]) {
      # k=1
      single_ws = spatial_ws[(t-twindow):t,k]
      single_ws_hourly = sapply( seq(1, twindow+1, 6),
                                 function(i) {mean(single_ws[i:(i+5)], na.rm = TRUE)})
      if ( sum(!is.na(single_ws_hourly)) < 500 ) {
        n = n
      } else if ( !is.na(single_ws_hourly[601]) ) {
        n = n+1
        linear = lm(observation_hourly[1:600] ~ single_ws_hourly[1:600])
        single_estimation_csrt[n] = single_ws_hourly[601] * linear$coefficients[2] + linear$coefficients[1]
        mu_nbhd = mean(single_ws_hourly[1:600], na.rm = TRUE)
        single_sd_csrt[n] = 1 -
          sum( abs(observation_hourly[1:600] - single_ws_hourly[1:600]), na.rm = TRUE) /
          sum( abs(observation_hourly[1:600] - mu_nbhd) +
                 abs(single_ws_hourly[1:600] - mu_nbhd), na.rm = TRUE) # index of agreement
        csrt_nbhd_ws[n] = single_ws_hourly[601]
      } else { n = n }
      if (n == 5) { break }
    }
    estimation_csrt[t] = sum(single_estimation_csrt * single_sd_csrt, na.rm = TRUE) /
      sum(single_sd_csrt, na.rm = TRUE)
    sd_csrt[t] = sd(csrt_nbhd_ws, na.rm = TRUE)
  }
}


# plot
spatial_srt = as.data.frame(cbind(observation, estimation_srt))
srt = ggplot(spatial_srt, aes(estimation_srt, observation) ) +
  geom_bin2d(binwidth = c(0.5, 0.5)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw()

spatial_csrt = as.data.frame(cbind(observation, estimation_csrt))
csrt = ggplot(spatial_srt, aes(estimation_csrt, observation) ) +
  geom_bin2d(binwidth = c(0.5, 0.5)) +
  geom_abline(colour = 'darkred') +
  scale_fill_gradientn(trans = "log", breaks = c(1,8,60,400,1500), colours = terrain.colors(5)) +
  theme_bw()

grid.arrange(srt, csrt, ncol = 2)


t=9000
# 4. probability spatial consistency test
estimation_psct = as.numeric(matrix(NA, nrow = 1, ncol = 157825)) # estimation 4
sd_psct = estimation_psct # nbhd sd 4
for (t in notNA) {
  psct_nbhd_ws = spatial_ws[t,similar_nbhd_info_order[,1]]
  psct_nbhd = cbind(similar_nbhd_info_order, as.numeric(psct_nbhd_ws) )

}

plot(psct_nbhd[,4],psct_nbhd[,5])

###############################################################
# plot & compare

res_rmse = estimation_srt - observation
res_geo = estimation_csrt - observation
idw_res = as.data.frame(cbind(res_rmse, res_geo))
mu_rmse = mean(res_rmse, na.rm = TRUE)
mu_geo = mean(res_geo, na.rm = TRUE)
sigma_rmse = sd(res_rmse, na.rm = TRUE)
sigma_geo = sd(res_geo, na.rm = TRUE)

res_idw_rmse = ggplot(idw_res) + theme_bw() +
  geom_histogram(aes(res_rmse), fill = 'steelblue', alpha = 0.8) +
  geom_vline(xintercept = (mu_rmse + 2*sigma_rmse), color = 'darkred', linetype = 'dashed') +
  geom_vline(xintercept = (mu_rmse - 2*sigma_rmse), color = 'darkred', linetype = 'dashed')
res_idw_geo = ggplot(idw_res) + theme_bw() +
  geom_histogram(aes(res_geo), fill = 'steelblue', alpha = 0.8) +
  geom_vline(xintercept = (mu_geo + 2*sigma_geo), color = 'darkred', linetype = 'dashed') +
  geom_vline(xintercept = (mu_geo - 2*sigma_geo), color = 'darkred', linetype = 'dashed')
grid.arrange(res_idw_rmse, res_idw_geo, ncol = 2)

res_idw_rmse = ggplot(idw_res,aes(res_rmse)) + theme_bw() +
  geom_density(kernel = "gaussian") +
  geom_vline(xintercept = (mu_rmse + 2*sigma_rmse), color = 'darkred', linetype = 'dashed') +
  geom_vline(xintercept = (mu_rmse - 2*sigma_rmse), color = 'darkred', linetype = 'dashed')
res_idw_geo = ggplot(idw_res,aes(res_geo)) + theme_bw() +
  geom_density(kernel = "gaussian") +
  geom_vline(xintercept = (mu_geo + 2*sigma_geo), color = 'darkred', linetype = 'dashed') +
  geom_vline(xintercept = (mu_geo - 2*sigma_geo), color = 'darkred', linetype = 'dashed')
grid.arrange(res_idw_rmse, res_idw_geo, ncol = 2)
